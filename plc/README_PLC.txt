MAGNET_ITLK_V15_20201125_0802 - The updated digital inputs (30 signals, changed some PV names). The last version before
		updating to TIA v15.1. The programmed interlock logic is below (not tested and maybe not complete).
MAGNET_ITLK_V15.1_20201125_1526.zap15_1 - Updated to TIA Portal V15.1. Updated the CPU firmware (in the project so it's the 
		same as in the hardware). Updated the Interlock conditions and the condition for LHe Flash box (the last version
		below)
MAGNET_ITLK_V15.1_20201202_1341 - FIxed the logic according to the last document. It requires some code cleaning (remove the unused
		objects - mainly dio objects.

Output and interlock logic:

#POLSW_INTERLOCK_1 := NOT("DIO_RDATA".POLSW_1_POS1.INTERLOCK XOR "DIO_RDATA".POLSW_1_POS2.INTERLOCK);

"DIO_RDATA".PC_1_PERMIT.INTERLOCK := "DIO_RDATA".NO_QUENCH.INTERLOCK OR
"DIO_RDATA".KEY1_OK.INTERLOCK OR
"DIO_RDATA".DAQ_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".EE_1_CLOSED.INTERLOCK OR "DIO_RDATA".EE_1_NO_ERROR_CL.INTERLOCK OR
"DIO_RDATA".EE_1_PC_SPA_OK.INTERLOCK OR
"DIO_RDATA".EE_1_POWER_PERM.INTERLOCK OR "DIO_RDATA".EE_1_REMOTE.INTERLOCK OR
"DIO_RDATA".LEAD_1_TEMP_OK.INTERLOCK OR "DIO_RDATA".LEAD_2_TEMP_OK.INTERLOCK OR
"DIO_RDATA".LEAD_1_VOLT_OK.INTERLOCK OR "DIO_RDATA".LEAD_2_VOLT_OK.INTERLOCK OR
"DIO_RDATA".PC_1_CONNECT.INTERLOCK OR "DIO_RDATA".PC_1_EXT_OUT.INTERLOCK OR
"DIO_RDATA".PC_1_POWER_Failure.INTERLOCK OR NOT("CPU_RDATA".CPU_CONF.GERSEMI_COM_OK) OR
"DIO_RDATA".EE_1_FS.INTERLOCK OR #POLSW_INTERLOCK_1;

#POLSW_INTERLOCK_2 := NOT("DIO_RDATA".POLSW_2_POS1.INTERLOCK XOR "DIO_RDATA".POLSW_2_POS2.INTERLOCK);

"DIO_RDATA".PC_2_PERMIT.INTERLOCK := "DIO_RDATA".NO_QUENCH.INTERLOCK OR
"DIO_RDATA".KEY2_OK.INTERLOCK OR
"DIO_RDATA".DAQ_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".EE_2_CLOSED.INTERLOCK OR "DIO_RDATA".EE_2_NO_ERROR_CL.INTERLOCK OR
"DIO_RDATA".EE_2_PC_SPA_OK.INTERLOCK OR
"DIO_RDATA".EE_2_POWER_PERM.INTERLOCK OR "DIO_RDATA".EE_2_REMOTE.INTERLOCK OR
"DIO_RDATA".LEAD_3_TEMP_OK.INTERLOCK OR "DIO_RDATA".LEAD_4_TEMP_OK.INTERLOCK OR
"DIO_RDATA".LEAD_3_VOLT_OK.INTERLOCK OR "DIO_RDATA".LEAD_4_VOLT_OK.INTERLOCK OR
"DIO_RDATA".PC_2_CONNECT.INTERLOCK OR "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK OR
"DIO_RDATA".PC_2_POWER_Failure.INTERLOCK OR NOT("CPU_RDATA".CPU_CONF.GERSEMI_COM_OK) OR
"DIO_RDATA".EE_2_FS.INTERLOCK OR #POLSW_INTERLOCK_1;

// Direct Power Abort Interlock
// 

// Fast power abort
// 
"DIO_RDATA".PC_1_EXT.INTERLOCK := "DIO_RDATA".KEY1_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".NO_QUENCH.INTERLOCK OR #POLSW_INTERLOCK_1;

"DIO_RDATA".PC_2_EXT.INTERLOCK := "DIO_RDATA".KEY2_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".NO_QUENCH.INTERLOCK OR #POLSW_INTERLOCK_2;

// EE open request
// 
"IEC_Timer_EE1_DB".TP(IN:="DIO_RDATA".PC_1_EXT.INTERLOCK,
                    PT:=#pulse_time,
                    Q=>#EE_1_Open_RQ,
                    ET=>#t1);
"EE_1_OPEN_RQ" := NOT(#EE_1_Open_RQ);

"IEC_Timer_EE2_DB".TP(IN:="DIO_RDATA".PC_2_EXT.INTERLOCK,
                      PT:=#pulse_time,
                      Q=>#EE_2_Open_RQ,
                      ET=>#t2);
"EE_2_OPEN_RQ" := NOT (#EE_2_Open_RQ);


// Flash lights
//
"CPU_RDATA".CPU_CONF.FLSHBX_HV := NOT  ("DIO_RDATA".PC_1_EXT_OUT.INTERLOCK AND "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK);
"FLSHBX_HVOLT" := "CPU_RDATA".CPU_CONF.FLSHBX_HV;

"CPU_RDATA".CPU_CONF.FLSHBX_HC := NOT ("DIO_RDATA".PC_1_EXT_OUT.INTERLOCK AND "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK);
"FLSHBX_HCUR" := "CPU_RDATA".CPU_CONF.FLSHBX_HC;

"CPU_RDATA".CPU_CONF.FLSHBX_He := NOT ("DIO_RDATA".PC_1_PERMIT.INTERLOCK AND "DIO_RDATA".PC_2_PERMIT.INTERLOCK);
"FLSHBX_HE" := "CPU_RDATA".CPU_CONF.FLSHBX_He;

=======================================================================================================================
MAGNET_ITLK_V15.1_20210211_1207 - Changed the interlock logic (removed "DIO_RDATA".PC_1/2_EXT_OUT.INTERLOCK) and
		set "DIO_RDATA".PC_1/2_EXT_OUT.INTERLOCK.N_LATCHED = 1.
		Changed the logic of the HV and HCUR flash lamps

// Power Converter Permit interlock
// 

#POLSW_INTERLOCK_1 := NOT("DIO_RDATA".POLSW_1_POS1.INTERLOCK XOR "DIO_RDATA".POLSW_1_POS2.INTERLOCK);

"DIO_RDATA".PC_1_PERMIT.INTERLOCK := "DIO_RDATA".NO_QUENCH.INTERLOCK OR
"DIO_RDATA".KEY1_OK.INTERLOCK OR
"DIO_RDATA".DAQ_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".EE_1_CLOSED.INTERLOCK OR "DIO_RDATA".EE_1_NO_ERROR_CL.INTERLOCK OR
"DIO_RDATA".EE_1_PC_SPA_OK.INTERLOCK OR
"DIO_RDATA".EE_1_POWER_PERM.INTERLOCK OR "DIO_RDATA".EE_1_REMOTE.INTERLOCK OR
"DIO_RDATA".LEAD_1_TEMP_OK.INTERLOCK OR "DIO_RDATA".LEAD_2_TEMP_OK.INTERLOCK OR
"DIO_RDATA".LEAD_1_VOLT_OK.INTERLOCK OR "DIO_RDATA".LEAD_2_VOLT_OK.INTERLOCK OR
"DIO_RDATA".PC_1_CONNECT.INTERLOCK OR
"DIO_RDATA".PC_1_POWER_Failure.INTERLOCK OR NOT("CPU_RDATA".CPU_CONF.GERSEMI_COM_OK) OR
"DIO_RDATA".EE_1_FS.INTERLOCK OR #POLSW_INTERLOCK_1;

#POLSW_INTERLOCK_2 := NOT("DIO_RDATA".POLSW_2_POS1.INTERLOCK XOR "DIO_RDATA".POLSW_2_POS2.INTERLOCK);

"DIO_RDATA".PC_2_PERMIT.INTERLOCK := "DIO_RDATA".NO_QUENCH.INTERLOCK OR
"DIO_RDATA".KEY2_OK.INTERLOCK OR
"DIO_RDATA".DAQ_OK.INTERLOCK OR "DIO_RDATA".DC24V_AUX1_OK.INTERLOCK OR
"DIO_RDATA".DC24V_AUX2_OK.INTERLOCK OR
"DIO_RDATA".EE_2_CLOSED.INTERLOCK OR "DIO_RDATA".EE_2_NO_ERROR_CL.INTERLOCK OR
"DIO_RDATA".EE_2_PC_SPA_OK.INTERLOCK OR
"DIO_RDATA".EE_2_POWER_PERM.INTERLOCK OR "DIO_RDATA".EE_2_REMOTE.INTERLOCK OR
"DIO_RDATA".LEAD_3_TEMP_OK.INTERLOCK OR "DIO_RDATA".LEAD_4_TEMP_OK.INTERLOCK OR
"DIO_RDATA".LEAD_3_VOLT_OK.INTERLOCK OR "DIO_RDATA".LEAD_4_VOLT_OK.INTERLOCK OR
"DIO_RDATA".PC_2_CONNECT.INTERLOCK OR
"DIO_RDATA".PC_2_POWER_Failure.INTERLOCK OR NOT("CPU_RDATA".CPU_CONF.GERSEMI_COM_OK) OR
"DIO_RDATA".EE_2_FS.INTERLOCK OR #POLSW_INTERLOCK_1;

// Flash lights
//
"CPU_RDATA".CPU_CONF.FLSHBX_HV := "DIO_RDATA".PC_1_EXT_OUT.INTERLOCK OR "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK;
"FLSHBX_HVOLT" := "CPU_RDATA".CPU_CONF.FLSHBX_HV;

"CPU_RDATA".CPU_CONF.FLSHBX_HC :=  "DIO_RDATA".PC_1_EXT_OUT.INTERLOCK OR "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK;
"FLSHBX_HCUR" := "CPU_RDATA".CPU_CONF.FLSHBX_HC;
===========================================================================================================================

MAGNET_ITLK_V15.1_20210617_2021 - Fixed a bug: the firs polarity switch input state was written to both pos1 and pos2 switch data.
MAGNET_ITLK_V15.1_20210617_2051 - Changed all input bits for EE* and PC* to be not latched.
MAGNET_ITLK_V15.1_20220215_1653 - Added support for control of polarity switches.

"DIO_RDATA".POLSW_1_POS1.DTYP := "DI";
"DIO_RDATA".POLSW_1_POS1.INVERT := FALSE;
"DIO_RDATA".POLSW_1_POS1.N_LATCH := TRUE;
"DIO_RDATA".POLSW_1_POS2.DTYP := "DI";
"DIO_RDATA".POLSW_1_POS2.INVERT := FALSE;
"DIO_RDATA".POLSW_1_POS2.N_LATCH := TRUE;
"DIO_RDATA".POLSW_2_POS1.DTYP := "DI";
"DIO_RDATA".POLSW_2_POS1.INVERT := FALSE;
"DIO_RDATA".POLSW_2_POS1.N_LATCH := TRUE;
"DIO_RDATA".POLSW_2_POS2.DTYP := "DI";
"DIO_RDATA".POLSW_2_POS2.INVERT := FALSE;
"DIO_RDATA".POLSW_2_POS2.N_LATCH := TRUE;
"DIO_RDATA".POLSW_DIR_POS1_RQ.DTYP := "DO";
"DIO_RDATA".POLSW_DIR_POS1_RQ.N_LATCH := TRUE;
// ??????????? No effect ?????????????? "DIO_RDATA".POLSW_DIR_POS1_RQ.N_FORCE := TRUE;
"DIO_RDATA".POLSW_DIR_POS2_RQ.DTYP := "DO";
"DIO_RDATA".POLSW_DIR_POS2_RQ.N_LATCH := TRUE;
// ??????????? No effect ?????????????? "DIO_RDATA".POLSW_DIR_POS2_RQ.N_FORCE := TRUE;
// Polarity switch directions (change the polarity under condition that none of the motors is running)
// 

"R_TRIG_DB_1"(CLK :="CPU_WDATA".CPU_CONF.POLSW_DIR_POS1,
            Q => #to_pos1_trig);
IF #to_pos1_trig AND NOT ("POLSW_1_MTR_ON_RQ" OR "POLSW_2_MTR_ON_RQ") THEN
    "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK := TRUE;
    "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK := FALSE;
END_IF;

"R_TRIG_DB_2"(CLK := "CPU_WDATA".CPU_CONF.POLSW_DIR_POS2,
            Q => #to_pos2_trig);
IF #to_pos2_trig AND NOT ("POLSW_1_MTR_ON_RQ" OR "POLSW_2_MTR_ON_RQ") THEN
    "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK := FALSE;
    "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK := TRUE;
END_IF;

// Polarity switch motors on interlock
// 

// Motor 1
#mtr_1_trig := "CPU_WDATA".CPU_CONF.POLSW_1_MTR_ON AND
    (NOT "DIO_RDATA".PC_1_EXT_OUT.INTERLOCK) AND
    (("DIO_RDATA".POLSW_1_POS1.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK) OR
    ("DIO_RDATA".POLSW_1_POS2.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK));
// Start the motor timer on the request from the operator
// 
    "IEC_Timer_MTR_1_DB".TP(IN:=#mtr_1_trig,
                            PT:=t#5s,
                            Q => #mtr_1_on_rq);
                        
    "POLSW_1_MTR_ON_RQ" := #mtr_1_on_rq AND
    (NOT "DIO_RDATA".PC_1_EXT_OUT.INTERLOCK) AND
    (("DIO_RDATA".POLSW_1_POS1.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK) OR
    ("DIO_RDATA".POLSW_1_POS2.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK));
    "CPU_RDATA".CPU_CONF.POLSW_1_MTR_ON := "POLSW_1_MTR_ON_RQ";
   
// Motor 2
    #mtr_2_trig := "CPU_WDATA".CPU_CONF.POLSW_2_MTR_ON AND
    (NOT "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK) AND
    (("DIO_RDATA".POLSW_2_POS1.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK) OR
    ("DIO_RDATA".POLSW_2_POS2.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK));
    // Start the motor timer on the request from the operator
    // 
    "IEC_Timer_MTR_2_DB".TP(IN:=#mtr_2_trig,
                            PT:=t#5s,
                            Q => #mtr_2_on_rq);
    "POLSW_2_MTR_ON_RQ" := #mtr_2_on_rq AND
    (NOT "DIO_RDATA".PC_2_EXT_OUT.INTERLOCK) AND
    (("DIO_RDATA".POLSW_2_POS1.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS1_RQ.INTERLOCK) OR
    ("DIO_RDATA".POLSW_2_POS2.INTERLOCK AND "DIO_RDATA".POLSW_DIR_POS2_RQ.INTERLOCK));
    "CPU_RDATA".CPU_CONF.POLSW_2_MTR_ON := "POLSW_2_MTR_ON_RQ";
    
